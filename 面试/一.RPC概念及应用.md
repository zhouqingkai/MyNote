#### 一.RPC概念及应用

​	RPC 的全称是 Remote Procedure Call 是一种进程间通信方式。 它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。即程序员无论是调用本地的还是远程的函数，本质上编写的调用代码基本相同。

​	通俗一点说，就是一般程序员对于本地的过程调用很熟悉，那么我们把 RPC 做成和本地调用完全类似，那么就更容易被接受，使用起来毫无障碍。 Nelson 的论文发表于 30 年前，其观点今天看来确实高瞻远瞩，今天我们使用的 RPC 框架基本就是按这个目标来实现的。

​	RPC 的主要目标是让构建分布式计算（应用）更容易，在提供强大的远程调用能力时不损失本地调用的语义简洁性。 为实现该目标，RPC 框架需提供一种透明调用机制让使用者不必显式的区分本地调用和远程调用。

​	RPC 调用分以下两种：

1. 同步调用：客户端等待调用执行完成并获取到执行结果。
2. 异步调用：客户端调用后不用等待执行结果返回，但依然可以通过回调通知等方式获取返回结果。若客户端不关心调用返回结果，则变成单向异步调用，单向调用不用返回结果。

异步和同步的区分在于是否等待服务端执行完成并返回结果。

![image-20200409133340952](%E4%B8%80.RPC%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%BA%94%E7%94%A8.assets/image-20200409133340952.png)

​	这里 User 就是 Client 端。当 User 想发起一个远程调用时，它实际是通过本地调用 User-stub。 User-stub 负责将调用的接口、方法和参数通过约定的协议规范进行编码并通过本地的 RPCRuntime 实例传输到远端的实例。 远端 RPCRuntime 实例收到请求后交给 Server-stub 进行解码后发起向本地端 Server 的调用，调用结果再返回给 User 端。

![image-20200409133724059](%E4%B8%80.RPC%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%BA%94%E7%94%A8.assets/image-20200409133724059.png)

​	RPC 服务端通过 RpcServer 去导出（export）远程接口方法，而客户端通过 RpcClient 去导入（import）远程接口方法。客户端像调用本地方法一样去调用远程接口方法，RPC 框架提供接口的代理实现，实际的调用将委托给代理 RpcProxy。代理封装调用信息并将调用转交给 RpcInvoker 去实际执行。在客户端的 RpcInvoker 通过连接器 RpcConnector 去维持与服务端的通道 RpcChannel，并使用 RpcProtocol 执行协议编码（encode）并将编码后的请求消息通过通道发送给服务端。

​	RPC 服务端接收器 RpcAcceptor 接收客户端的调用请求，同样使用RpcProtocol执行协议解码（decode）。

​	解码后的调用信息传递给 RpcProcessor 去控制处理调用过程，最后再委托调用给 RpcInvoker 去实际执行并返回调用结果。

​	组件功能：

1. RpcServer
   负责导出（export）远程接口

2. RpcClient
   负责导入（import）远程接口的代理实现

3. RpcProxy
   远程接口的代理实现

4. RpcInvoker
   客户端：负责编码调用信息和发送调用请求到服务端并等待调用结果返回
   服务端：负责调用服务端接口的具体实现并返回调用结果

5. RpcProtocol
   负责协议编/解码

6. RpcConnector
   负责维持客户端和服务端的连接通道和发送数据到服务端

7. RpcAcceptor
   负责接收客户端请求并返回请求结果

8. RpcProcessor`
   负责在服务端控制调用过程，包括管理调用线程池、超时时间等

9. RpcChannel
   数据传输通道

   ​	**实现**

   Nelson 论文中给出的这个概念模型也成为后来大家参考的标准范本。十多年前，我最早接触分布式计算时使用的 CORBAR（参考[3]）实现结构基本与此基本类似。CORBAR 为了解决异构平台的 RPC，使用了 IDL（Interface Definition Language）来定义远程接口，并将其映射到特定的平台语言中。

   

   后来大部分的跨语言平台 RPC 基本都采用了此类方式，比如我们熟悉的 Web Service（SOAP），近年开源的 Thrift 等。 他们大部分都通过 IDL 定义，并提供工具来映射生成不同语言平台的 User-stub 和 Server-stub，并通过框架库来提供 RPCRuntime 的支持。 不过貌似每个不同的 RPC 框架都定义了各自不同的 IDL 格式，导致程序员的学习成本进一步上升。而 Web Service 尝试建立业界标准，无赖标准规范复杂而效率偏低，否则 Thrift 等更高效的 RPC 框架就没必要出现了。

   

   IDL 是为了跨平台语言实现 RPC 不得已的选择，要解决更广泛的问题自然导致了更复杂的方案。 而对于同一平台内的 RPC 而言显然没必要搞个中间语言出来，例如 Java 原生的 RMI，这样对于 Java 程序员而言显得更直接简单，降低使用的学习成本。

   

   在上文进一步拆解了组件并划分了职责之后，下面就以在 Java 平台实现该 RPC 框架概念模型为例，详细分析下实现中需要考虑的因素。