#### 三.解析配置文件redis.conf

##### 1、redis配置文件常用配置信息
		redis对于大小写不区分

​		添加密码

​	![1565788806321](E:\Typora笔记\Pic\1565788806321.png)

​	![1565788870778](E:\Typora笔记\Pic\1565788870778.png)

​		redis缓存过期清除策略

![1565789266616](E:\Typora笔记\Pic\1565789266616.png)

​		**LRU算法**

​	基于 JDK 提供的 LinkedHashMap 的实现。

​	**LinkedHashMap**说明：

- **LinkedHasnMap**内部维护的是双向链表，用来维护插入顺序或 LRU 顺序。
- 它继承**HashMap**，具有快速查询的特性。
- 头节点**head**是最老的节点，尾节点是最近一次被访问的节点，维护 LRU 顺序时，容量用完后，再执行插入新的数据时，会将头节点移除。
- **accessOrder**表示维护那种顺序，默认为 false。true：代表 LRU 顺序，false：代表插入顺序。

```java
public class LRUCache<k, v> extends LinkedHashMap<k, v> {

  //最多能缓存的数据
  private final int CACHE_SIZE;

  public LRUCache(int cacheSize) {
    //true 表示让linkedHashMap按照访问顺序来进行排序，最近访问的放在头部，最老访问的放在尾部
    super((int)Math.ceil(cacheSize / 0.75) + 1, 0.75f, true);
    CACHE_SIZE = cacheSize;
  }

  @Override
  protected boolean removeEldestEntry(Map.Entry<k, v> eldest) {
    //当map中的数据量大于指定的缓存个数的时候，就自动删除最老的数据
    return size() > CACHE_SIZE;
  }
}
```



​	常见redis.conf配置介绍

守护进程作用：在 linux 中，每一个系统与用户进行交流的界面称为终端
如果没有开启守护进程，相当于知识在前台开启了Redis，当终端关闭时，Reids服务也会跟着关闭
而开启守护进程后，相当于是在后台运行，脱离终端，不会再关闭终端时停止Redis服务进程

![1565789452559](E:\Typora笔记\Pic\1565789452559.png)

![1565789546528](E:\Typora笔记\Pic\1565789546528.png)

![1565789566717](E:\Typora笔记\Pic\1565789566717.png)

![1565789726341](E:\Typora笔记\Pic\1565789726341.png)

##### 2.redis持久化（重点）

###### 1)RDB:		Redis	DataBase

​		RDB保存的是dump.rdb文件

​		在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话		讲的Snapshot快照，它恢复时是将快照文件直接读到内存中。

​		Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写		入到一个临时文件中，待持久化过程结束了。在用这个临时文件替		换上次持久化好的文件，整个过程中，主进程是不进行任何IO操作		的，这就确保了极高的性能，如果需要进行大规模数据的恢复，且		对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更		加的高效，RDB的缺点是最后一次持久化的数据可能丢失。

​		FORK:

​				fork的作用是复制一个与当前进程一样的进程，新进程的所有				数据（变量，环境变量，程序计数器等）数值都和原进程一				致，但是是一个全新的进程，并作为原进程的子进程。

​		

​		三种方式会触发缓存内容，生成.rdb文件

![1565792640697](E:\Typora笔记\Pic\1565792640697.png)

![1565792671904](E:\Typora笔记\Pic\1565792671904.png)

​		查看redis是否启动的两种方法

![1565793189628](E:\Typora笔记\Pic\1565793189628.png)

​		在5分钟内变更10次，5分钟之后自动会生成 dump.rdf 文件

![1565793424446](E:\Typora笔记\Pic\1565793424446.png)

​		在重新启动之后，会将名称叫做  dump.rdb  文件从硬盘文件中读回		内存，加载到redis缓存中。

​		(假如执行的是flushall或者shotdown指令时，回清空当前缓存数据，		并立即生成dump.rdb文件，造成即使读回内存，内容仍然为空）

​		![1565794283470](E:\Typora笔记\Pic\1565794283470.png)

​		如果想要手动触发生成dump.rdb文件，使用save指令

![1565794512199](E:\Typora笔记\Pic\1565794512199.png)

​		当出现保存异常时，前台停止写的操作

![1565794746384](E:\Typora笔记\Pic\1565794746384.png)

​		对快照压缩存储

![1565794881777](E:\Typora笔记\Pic\1565794881777.png)

![1565794915211](E:\Typora笔记\Pic\1565794915211.png)



​	触发RDB快照的三种方式：

​			1）配置文件中的默认自动快照配置

​					冷拷贝之后重新使用，可以拷贝一下 

​					cp  dump.rdb   dump_new.rdb

​			2）手动命令save或者是bgsave

​					save指令只管保存，其他不管，全部阻塞

​					bgsave指令：redis会在后台异步进行快照操作，快照的同时						还可以响应客户端请求，可以通过lastsave命令获取最后						一次成功执行快照的时间

​			3）执行flushall命令

​					也会产生dump.rdb文件，但是里面是空的，没有意义

​	如何从硬盘将dump.rdb文件恢复至内存中

​			将备份文件dump.rdb移动到redis安装目录中并启动服务器即可

​					config    get   dir    		：获取目录

​	优势：适合大规模的数据恢复

​			   对数据完整性和一致性要求度不高

​	劣势：在一定时间间隔做一次备份，所以如果redis意外down掉的话，				就会丢失最后一次快照后的所有修改

​				fork的时候，内存中的数据被克隆了一份，导致两倍的膨胀性				能需要考虑

​	

​	如何停止：

​			动态停止所有RDB保存规则的方法：

​						redis-cli	config    set    ""

​	总结：

![1565795872644](E:\Typora笔记\Pic\1565795872644.png)

​				



###### 2）AOF:		Append	Only	File

​	含义：	以日志的形式记录每个写文件操作，将Redis执行过的所有写指令记录				   下来（读操作不记录），只需追加文件但不可改写文件，redis启动之初				   会读取该文件重新构造数据，换言之，redis重启的话就根据日志文件				   的内容将写指令从前到后执行一次已完成数据的恢复工作。

​	AOF保存的是appendonly.aof文件

​	修改conf  文件，默认为no，改为yes，开启AOF功能

​	默认生成AOF文件名：appendonly.aof文件

![1565936211699](E:\Typora笔记\Pic\1565936211699.png)

​	当启动appendonly  yes  时，开启redis业务，自动生成要写入的文件appendonly.aof

![1565948223685](E:\Typora笔记\Pic\1565948223685.png)

​	当对redis进行set（即插入操作时），自动往appendonly.aof中写入操作（flushall操作也会记录进去）

![1565948382609](E:\Typora笔记\Pic\1565948382609.png)

![1565948500837](E:\Typora笔记\Pic\1565948500837.png)

​	在重新启动redis服务器的时候，会重新加载appendonly.aof文件，从磁盘文件中将数据加载回来

![1565948704133](E:\Typora笔记\Pic\1565948704133.png)

​	如果appendonly.aof文件受损，无法恢复数据的话，当redis启动时会先寻找aof文件（rdb文件和aof可以同时存在，优先加载aof文件），此时无法启动redis，redis   refused

![1566009531287](E:\Typora笔记\Pic\1566009531287.png)

​	此时调用

​			redis-check-aof     --fix   appendonly.aof			指令

​			会将aof文件不符合恢复语法的语句删除，并保存为可执行的aof文件

![1566009756320](E:\Typora笔记\Pic\1566009756320.png)

​	

​	aof备份策略	：

​	Appendfsync	

​				always	：同步持久化，每次发生数据变更会被立即记录到磁盘中，性能								   较差但数据完整性比较好

（默认）Everysec	:出厂默认推荐，异步操作，美妙记录，如果一秒之内宕机，									有数据丢失



​	rewrite	:

​				AOF采用文件追加方式，文件会越来越大，为了避免这种情况，新增了重				写机制，当aof文件的大小超过所设定的阈值时，redis就会启动aof文件的				内容压缩，只保留可以恢复数据的最小指令集，可以使用命令    									bgrewriteaof

​	rewrite原理：

​			aof文件持续增长时，会fork初一条新进程来将文件重写（也是先写临时文件最后在rename），遍历新进程的内存中的数据，每条记录有一条的set语句，重写aof文件的操作，并没有读取旧的aof文件，而是将整个数据库的文件以

​			redis会记录上次重写时的aof大小，默认配置是当aof文件大小是上次rewrite后大小的一倍且文件大于64M时触发



​	AOF优势：

​			每秒同步：appendfsync  always  同步持久化  每次发生数据变更时会被李锦记记录到磁盘，性能较差但数据完整性比较好，

​			每修改同步：appendfsync   everysec  异步操作，每秒记录，如果一秒之内宕机，有数据丢失

​			不同步：	appendfsync  no   从不同步

​	AOF劣势：

​			相同数据集的数据而言aof文件要远大于rdb文件，恢复速度慢于rdb

aof文件运行效率要慢于rdb，美妙同步策略效率较好，不同步时效率和rdb相同



​		总结

![1566023863340](E:\Typora笔记\Pic\1566023863340.png)

​			RDB持久化方式能够在指定的时间间隔对你的数据进行快照存储

​			AOF持久化方式记录每次对服务器的写的操作，当服务器重启的时候会重新执行这些命令来恢复原始数据，AOF命令以redis协议追加保存每次写的操作到文件末尾，redis还能对aof文件进行后台重写，使得aof文件体积不至于过大

​			如果只希望redis做缓存，也就是说只希望你的数据在服务器上运行时存在，也可以不使用任何持久化操作

​			如果同时开启两种持久化操作，当redsi重启的时候会优先载入aof文件来恢复原始的数据，因为通常情况下aof文件保存的数据集要比RDB文件保存的数据集完整

​			RDB文件数据不全时，同时使用两种持久化策略也会先找aof文件，尽量不要只使用aof持久化策略，因为RDB更适合用于备份数据库（aof在不断变化不好备份），而且不会有aof可能潜在的bug，留着作为一个万一的手段

​	性能建议	:

![1566034432239](E:\Typora笔记\Pic\1566034432239.png)



​				