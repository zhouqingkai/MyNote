#### 一.JVM构成及作用

![image-20200421222359990](%E4%B8%80.JVM%E6%9E%84%E6%88%90%E5%8F%8A%E4%BD%9C%E7%94%A8.assets/image-20200421222359990.png)

![image-20200422102414348](%E4%B8%80.JVM%E6%9E%84%E6%88%90%E5%8F%8A%E4%BD%9C%E7%94%A8.assets/image-20200422102414348.png)

##### 1.类加载器

​	Java类加载器是用来在运行时加载类(*.class文件)。Java类加载器基于三个原则：委托、可见性、唯一性。

​	**委托原则**把加载类的请求转发给父类加载器，而且仅加载类当父类加载器无法找到或者不能加载类时。

​	**可见性原则**允许子类加载器查看由父类加载器加载的所有的类，但是父类加载器不能查看由子类加载器加载的类。

​	**唯一性原则**只允许加载一次类文件，这基本上是通过委托原则来实现的并确保子类加载器不重新加载由父类加载器加载过的类。正确的理解类加载器原理必须解决像 NoClassDefFoundError in Java、 java.lang.ClassNotFoundException（这些现象和加载类有关系）的问题。

###### 1)什么是Java的类加载器

​	Java中的类加载器是加载Java类文件（*.class）的一个类。Java代码被javac 编译器编译后以字节码的形式保存到类文件，JVM（Java虚拟机）通过操作类文件里的字节码来执行Java程序。类加载器负责从文件系统、网络或任何其它资源中加载类文件。Java中使用的默认类加载器有以下三种：**Bootstrap , Extension** 以及 **System or Application class loader** 。每个类加载器都有一个预定义的位置，它们在那里加载类文件。Bootstrap 类加载器负责从rt.jar中加载标准JDK类文件，并且它是Java中所有类加载器的父级。**Bootstrap**类加载器没有任何父级，如果你调用String.class.getClassLoader()则返回null 而且与此相关的代码则抛出空指针异常。**Bootstrap**类加载器在java中也被称为**Primordial ClassLoader****(**原生类加载器**)** 。**Extension** 类加载器委托它的父级**Bootstrap**类加载器来加载类文件，如果委托失败，则从指向java.ext.dirs 系统属性的jre/lib/ext目录或者任何其它目录加载类文件。**JVM**中的**Extension** 类加载器被sun.misc.Launcher$ExtClassLoader实现。 **JVM** 使用的第三种默认类加载器就是**System or Application** **class loader** ，它主要负责从**CLASSPATH**环境变量中加载应用程序特定的类文件，-classpath or -cp 命令行选项， JAR内部清单文件的类路径属性。**Application**类加载器是**Extension** 类加载器的子级，它由sun.misc.Launcher$AppClassLoader类实现。而且，除**Bootstrap** 类加载器（大都由**C** 语言实现）以外，所有的Java类加载器使用java.lang.ClassLoader 来实现。

![image-20200422095036571](%E4%B8%80.JVM%E6%9E%84%E6%88%90%E5%8F%8A%E4%BD%9C%E7%94%A8.assets/image-20200422095036571.png)

简而言之，这三种类加载器加载类文件的路径如下：

1） Bootstrap ClassLoader - JRE/lib/rt.jar

2） Extension ClassLoader - JRE/lib/ext 或者任何指向java.ext.dirs的路径

3） Application ClassLoader - **CLASSPATH**环境变量、-classpath or -cp 命令行选项，JAR内部清单文件的类路径属性

###### 2）类加载器的工作原理

​	**委托原则**

​	假设您有一个叫做Abc.class 的应用程序特定的类文件，加载这个类文件的第一个请求发送到**Application**类加载器。**Application**类加载器委托它的父级**Extension** 类加载器，而**Extension**类加载器委托给**Bootstrap**类加载器。**Bootstrap**类加载器在rt.jar 中寻找类文件，由于没有找到，请求转发到**Extension** 类加载器。**Extension** 类加载器在jre/lib/ext目录中寻找类文件并尝试加载类文件，如果找到了类文件，这时**Extension** 类加载器将会加载类文件（**Application**类加载器将永远不会加载类文件）；但是如果**Extension** 类加载器没有加载类文件，那么**Application**类加载器将会从java类路径中加载类文件。请注意：类路径用于加载类文件，而路径用来查找可执行的像javac or java 的命令。

​	**可见性**

​	根据可见性原则，子级类加载器可以看到父级类加载器加载的类文件，但是反过来则行不通。这意味着，假如**Application**类加载器加载了Abc.class 文件，那么尝试使用**Extension** 类加载器去加载Abc.class 文件，则会抛出异常java.lang.ClassNotFoundException。请看下面的示例

​	**唯一性原则**

​	根据这个原则，一个类文件被父级类加载器加载后，子级类加载器则不能加载它。尽管完全可以编写一个类加载器，它自己加载类文件，这违反了委托和唯一性原则，这样做没有什么好处。在您编写您自己的类加载器时，您应当遵守所有的类加载器原则

###### 3）Java如何准确加载类

​	java提供了API通过Class.forName(classname) 和Class.forName(classname, initialized, classloader)方法来明确加载一个类，还记得JDBC中用来加载JDBC驱动的方式吗，就是使用该机制来加载对应的类。就像我们在上边例子中展示的一样，你可以将加载特定类的加载器的名称连同类的二进制名称一起作为参数传进来。Class是通过调用java.lang.ClassLoader的loadClass()方法，该方法又会调用findClass()方法来为相应类查找对应的字节码。在这个例子中扩展类加载器使用java.lang.URLClassLoader用来在jar包和目录中查找类文件以及资源。其中，查询中所有以"/"结尾的的都会被当作目录处理。如果findClass()方法没有找到相关类，那么它会抛出java.lang.ClassNotFoundException异常；如果该方法找到了相关类，它会调用defineClass()方法来将字节码转换为.class的实例并将该实例返回给调用者。

##### 2.线程独有区域

###### 1）虚拟机栈

![image-20200422102557147](%E4%B8%80.JVM%E6%9E%84%E6%88%90%E5%8F%8A%E4%BD%9C%E7%94%A8.assets/image-20200422102557147.png)

​	内存区域虚拟机栈是数据结构，也是线程独有区域，每一个线程都会有自己独立的栈区域

​	每个方法都有自己的局部变量，比如上图中main方法中的result，add方法中的a b c，那么java虚拟机为了区分不同方法中局部变量作用域范围的内存区域，每个方法在运行的时候都会分配一块独立的栈帧内存区域，我们试着按上图中的程序来简单画一下代码执行的内存活动。

​	执行main方法中的第一行代码是，栈中会分配main()方法的栈帧，并存储局部变量,，接着执行add()方法，那么栈又会分配add()的栈帧区域。

这里的栈存储数据的方式和数据结构中学习的栈是一样的，先进后出。当add()方法执行完之后，就会出栈被释放，也就符合先进后出的特点，后调用的方法先出栈。

​	**栈帧**

![image-20200422103057497](%E4%B8%80.JVM%E6%9E%84%E6%88%90%E5%8F%8A%E4%BD%9C%E7%94%A8.assets/image-20200422103057497.png)

​	以add方法进行演示

​	**压栈**

​	将1压入操作数栈

![image-20200422103221060](%E4%B8%80.JVM%E6%9E%84%E6%88%90%E5%8F%8A%E4%BD%9C%E7%94%A8.assets/image-20200422103221060.png)

​	局部变量1，在我们代码中也就是第一个局部变量a，先给a在局部变量表中分配内存，然后将int类型的值，也就是目前唯一的一个1存入局部变量a

![image-20200422103330146](%E4%B8%80.JVM%E6%9E%84%E6%88%90%E5%8F%8A%E4%BD%9C%E7%94%A8.assets/image-20200422103330146.png)

![image-20200422103424499](%E4%B8%80.JVM%E6%9E%84%E6%88%90%E5%8F%8A%E4%BD%9C%E7%94%A8.assets/image-20200422103424499.png)

​	iadd指令一执行，会将操作数栈中的1和2依次从栈底弹出并相加，然后把运算结果3在压入操作数栈底。

![image-20200422103442641](%E4%B8%80.JVM%E6%9E%84%E6%88%90%E5%8F%8A%E4%BD%9C%E7%94%A8.assets/image-20200422103442641.png)

​	将100压入栈中

![image-20200422103503240](%E4%B8%80.JVM%E6%9E%84%E6%88%90%E5%8F%8A%E4%BD%9C%E7%94%A8.assets/image-20200422103503240.png)

​	将3和100弹出栈，把结果300压入栈

![image-20200422103531098](%E4%B8%80.JVM%E6%9E%84%E6%88%90%E5%8F%8A%E4%BD%9C%E7%94%A8.assets/image-20200422103531098.png)

​	add方法是被main方法中调用的，所以通过方法出口返回到mian方法中result变量存储方法出口说白了不就是方法执行完了之后要出到哪里，那么我们知道上面add()方法执行完之后应该回到main()方法第三行那么当main()方法调用add()的时候，add()栈帧中的方法出口就存储了当前要回到的位置，那么当add()方法执行完之后，会根据方法出口中存储的相关信息回到main()方法的相应位置。看图中的红线

![image-20200422103833828](%E4%B8%80.JVM%E6%9E%84%E6%88%90%E5%8F%8A%E4%BD%9C%E7%94%A8.assets/image-20200422103833828.png)

​	**也就是说每一个线程，方法都会在内存中开辟出一块栈帧区域，在栈帧的局部变量表使用字节码指令将数据进行运算最终通过方法出口，将最终结果的引用指针进行转移返回**

​	整体关系如下图：

![image-20200422104446555](%E4%B8%80.JVM%E6%9E%84%E6%88%90%E5%8F%8A%E4%BD%9C%E7%94%A8.assets/image-20200422104446555.png)

###### 2）本地方法栈

​	本地方法栈（Native Method Stacks）与 Java 虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的 Native 方法服务。虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。

​	**Navtive 方法是 Java 通过 JNI 直接调用本地 C/C++ 库**，可以认为是 Native 方法相当于 C/C++ 暴露给 Java 的一个接口，Java 通过调用这个接口从而调用到 C/C++ 方法。当线程调用 Java 方法时，虚拟机会创建一个栈帧并压入 Java 虚拟机栈。然而当它调用的是 native 方法时，虚拟机会保持 Java 虚拟机栈不变，也不会向 Java 虚拟机栈中压入新的栈帧，虚拟机只是简单地动态连接并直接调用指定的 native 方法。

​	**Native方法**

​	一个Native Method就是一个java调用非java代码的接口。一个Native Method是这样一个java的方法：该方法的实现由非java语言实现，比如C。这个特征并非java所特有，很多其它的编程语言都有这一机制，比如在C＋＋中，你可以用extern “C”告知C＋＋编译器去调用一个C的函数

![image-20200422105316080](%E4%B8%80.JVM%E6%9E%84%E6%88%90%E5%8F%8A%E4%BD%9C%E7%94%A8.assets/image-20200422105316080.png)

- 本地方法栈是一个后入先出（Last In First Out）栈。
- 由于是**线程私有**的，生命周期随着线程，线程启动而产生，线程结束而消亡。
- 本地方法栈会抛出 **StackOverflowError** 和 **OutOfMemoryError** 异常。

###### 3）程序计数器

​	程序计数器是一个记录着当前线程所执行的字节码的行号指示器

​	Java代码编译后的字节码在未经过JIT（实时编译器）编译前，其执行方式是通过“字节码解释器”进行解释执行。简单的工作原理为解释器读取装载入内存的字节码，按照顺序读取字节码指令。读取一个指令后，将该指令“翻译”成固定的操作，并根据这些操作进行分支、循环、跳转等流程

​	JVM的多线程实现方式。JVM的多线程是通过CPU时间片轮转（即线程轮流切换并分配处理器执行时间）算法来实现的。也就是说，某个线程在执行过程中可能会因为时间片耗尽而被挂起，而另一个线程获取到时间片开始执行。当被挂起的线程重新获取到时间片的时候，它要想从被挂起的地方继续执行，就必须知道它上次执行到哪个位置，在JVM中，通过程序计数器来记录某个线程的字节码执行位置。因此，程序计数器是具备线程隔离的特性，也就是说，每个线程工作时都有属于自己的独立计数器。

​	**特点**

​	1.线程隔离性，每个线程工作时都有属于自己的独立计数器。
　 2.执行java方法时，程序计数器是有值的，且记录的是正在执行的字节码指令的地址（参考上一小节的描述）。
　 3.执行native本地方法时，程序计数器的值为空（Undefined）。因为native方法是java通过JNI直接调用本地C/C++库，可以近似的认为native方法相当于C/C++暴露给java的一个接口，java通过调用这个接口从而调用到C/C++方法。由于该方法是通过C/C++而不是java进行实现。那么自然无法产生相应的字节码，并且C/C++执行时的内存分配是由自己语言决定的，而不是由JVM决定的。

​    4.程序计数器占用内存很小，在进行JVM内存计算时，可以忽略不计。

　5.程序计数器，是唯一一个在java虚拟机规范中没有规定任何OutOfMemoryError的区域。

![image-20200422113313268](%E4%B8%80.JVM%E6%9E%84%E6%88%90%E5%8F%8A%E4%BD%9C%E7%94%A8.assets/image-20200422113313268.png)

##### 3.线程共有区域

###### 1）方法区（永久代）

​	方法区和堆一样，是所有线程共享的内存区域

​	JDK1.7之前（永久代）用于存储已被虚拟机加载的类信息，常量，字符串常量，类静态变量，即时编译器编译后的代码等数据

​	运行时常量池（Runtime Constant Pool）是方法区的一部分。Class 文件中除了有类的版本/字段/方法/接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将类在加载后进入方法区的运行时常量池中存放。运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多