#### 一.Redis事件驱动模型+IO多路复用

​	Redis中所有命令执行都是基于事件驱动模型的，结合IO多路复用机制，实现单进程单线程的高并发快速访问。

​	Redis中的事件包含文件事件和时间事件，文件事件基于客户端和Redis服务端建立Socket连接产生的事件，是对Socket连接的一个抽象概念。而时间事件指的是Redis服务端需要的定时出发的事件，类似于定时任务

##### 1.事件驱动模型

​	事件驱动的意思是只有发生某个事件时，程序才会有所行动。事件驱动模型在架构设计领域被称为Reactor 模式，体现的是一种被动响应的特征。模型流程图如下

![image-20200331220321464](C:%5CUsers%5Czhouqk%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200331220321464.png)

​	主程序处于一个阻塞状态的事件循环(event loop)中等待事件(event)，当有事件发生时，根据事件的属性分发到相应的处理函数进行处理。事件以并发的方式发送到服务处理器 (service handler)，服务处理器将事件整合到一个有序队列中（这过程称为demultiplexes），并分发到具体的请求处理器 (request handler)进行处理。

##### 2.Redis核心原理

​	Redis程序的整个运作都是围绕事件循环 (event loop)进行的，当有来自外部或内部的请求的时候，才会执行相关的流程。

​	事件循环对于 Redis 而言，就像是一台车的引擎一样，提供了整个系统所需的流转动力。所有其他的组件都是基于这个引擎的基础上组合和构建起来的。可以说理解了 Redis 的事件循环就能了解 Redis 的工作原理的核心。

​	Redis 事件模型如下图所示：

![image-20200331220455238](C:%5CUsers%5Czhouqk%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200331220455238.png)

​	Redis中循环事件本质上是对Socket连接的抽象，循环事件包括accept事件、read事件、write事件。

​	Redis中eventLoop中保存这events和fired两个事件队列，events中保存的是所有事件，而fired保存的是已就绪待处理的事件。

​	当Socker连接可读或者可写时，就把对应的事件加入到事件待处理队列fired中，以有序 (sequentially)、同步 (synchronously) 的方式发送给事件处理器进行处理。这个过程在Redis中被称为Fire。最后由事件对应的处理器（Handler）将处理的结果返回给客户端去。

​	Redis在实现这个过程时，采用了IO 多路复用 (multiplexing) 的方式，封装了操作系统底层 select/epoll 等函数，实现对多个套接字 (socket) 的监听，这些套接字就是对应多个不同客户端的连接。

​	通过以上概括了Redis 处理用户请求的大致过程。从这个过程我们可以发现：

- Redis 处理所有命令都是顺序执行的，其中包括来自客户端的连接请求。所以当 Redis 在处理一个复杂度高、时间很长的请求（比如 KEYS 命令）的时候，其他客户端的连接都没办法相应。
- Redis 内部定时执行的任务也是放在顺序队列中处理，其中也可能包含时间较长的任务，比如自动删除一个过期的大 Key，比如很大 list, hash, set 等。所以有时候会遇到明明业务没有主动操作复杂，但也会出现卡顿的问题。

##### 3.Redis的IO多路复用模块

​	I/O多路复用是一种机制，通过监视多个描述符，一旦某个描述符就绪，就通知程序进行相应的操作。多路-指的是多个socket连接，复用-指的是复用一个线程。

​	I/O多路复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗），且Redis在内存中操作数据的速度非常快（内存内的操作不会成为这里的性能瓶颈），主要以上两点造就了Redis具有很高的吞吐量。

​	多路复用主要有三种技术：select，poll，epoll。epoll是最新的也是目前最好的多路复用技术。

​	Redis中IO多路复用是封装了操作系统提供的select，epoll，avport和kqueue这些基础函数，向上层提供了一个统一的接口，屏蔽了底层实现的细节。现在看看Redis是怎么利用linux提供的epoll实现I/O 多路复用。

​	**epoll提供的3个方法：**

![image-20200331221036921](%E4%B8%80.Redis%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B+IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.assets/image-20200331221036921.png)

​	事件驱动模型的优势

​	有利于架构解耦和模块化开发，使功能架构实现上更加解耦，模块的可重用性更高。因`事件循环`的流程本身和具体的处理逻辑之间是独立的，只要在创建事件的时候关联特定的处理逻辑（`事件处理器`），就可以完成一次事件的创建和处理。

​	有利于减小高并发量情况下对性能的影响，相比一个连接分配一个线程的模型， Reactor 模式（固定线程数）在连接数增大的情况下吞吐量不会明显降低，延时也不会也受到显著的影响。

##### 为什么单线程可以承载高并发

\1. Redis是纯内存数据库，一般都是简单的存取操作，线程占用的时间很多，时间的花费主要集中在IO上，所以读取速度快。

\2. Redis使用的是非阻塞IO，IO多路复用，使用了单线程来轮询描述符，将数据库的开、关、读、写都转换成了事件，减少了线程切换时上下文的切换和竞争。

\3. Redis采用了单线程的模型，保证了每个操作的原子性，也减少了线程的上下文切换和竞争。

\4. 数据结构，Redis全程使用hash结构，读取速度快，还有一些特殊的数据结构，对数据存储进行了优化，如压缩表，对短数据进行压缩存储，再如，跳表，使用有序的数据结构加快读取的速度。

5.Redis采用自己实现的事件分离器，效率比较高，内部采用非阻塞的执行方式，吞吐能力比较大。

​	 Redis采用IO多路复用技术，将多客户端的Socket连接、读、写转化为服务端文件的可读可写事件，并采用单线程循环的方式去拉取已就绪的事件，然后找到事件对应的处理器执行相应的处理操作，使用单线程减少了线程的上下文切换和竞争。这就是Redis的事件驱动模型，整个事件循环的逻辑过程都没有涉及具体的命令操作，只需要定义事件的类型和处理器即可，实现接收事件和处理流程相互解耦。